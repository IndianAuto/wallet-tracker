<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Polygon Wallet Manager</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.9.0/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0d1117;
      color: #e6edf3;
      min-height: 100vh;
    }

    /* Lock Screen */
    .lock-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }
    .lock-screen h1 { color: #8b5cf6; margin-bottom: 30px; }
    .lock-screen .subtitle { color: #7d8590; margin-bottom: 40px; }
    .lock-box {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 16px;
      padding: 40px;
      width: 100%;
      max-width: 400px;
    }
    .lock-box h2 { margin-bottom: 20px; font-size: 18px; }
    .lock-box input {
      width: 100%;
      padding: 14px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #0d1117;
      color: #e6edf3;
      font-size: 16px;
      margin-bottom: 20px;
    }
    .lock-box button {
      width: 100%;
      padding: 14px;
      border: none;
      border-radius: 8px;
      background: #8b5cf6;
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    .lock-box button:hover { background: #7c3aed; }
    .lock-box .error { color: #f85149; font-size: 14px; margin-top: 10px; }
    .lock-box .info { color: #7d8590; font-size: 12px; margin-top: 15px; text-align: center; }

    /* Main App */
    .app { display: none; padding: 20px; max-width: 1400px; margin: 0 auto; }
    .app.active { display: block; }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }
    .header h1 { color: #8b5cf6; }
    .header-actions { display: flex; gap: 10px; }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: #8b5cf6;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #7c3aed; }
    button:disabled { background: #30363d; cursor: not-allowed; }
    .btn-secondary { background: #30363d; }
    .btn-secondary:hover { background: #484f58; }
    .btn-danger { background: #f85149; }
    .btn-danger:hover { background: #da3633; }
    .btn-success { background: #3fb950; }
    .btn-success:hover { background: #2ea043; }
    .btn-small { padding: 6px 12px; font-size: 12px; }
    .btn-warning { background: #d29922; }
    .btn-warning:hover { background: #bb8009; }

    /* Wallet Type Tags */
    .wallet-type {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      margin-left: 8px;
    }
    .wallet-type.funding { background: #238636; color: #3fb950; }
    .wallet-type.proxy { background: #30363d; color: #7d8590; }

    /* Wallet Sections */
    .wallet-section { margin-bottom: 30px; }
    .wallet-section h2 {
      color: #7d8590;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #21262d;
    }

    /* Quick Fund */
    .quick-fund {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #21262d;
    }
    .quick-fund input {
      flex: 1;
      padding: 8px;
      border: 1px solid #30363d;
      border-radius: 6px;
      background: #0d1117;
      color: #e6edf3;
      font-size: 12px;
    }

    /* Total Balance Card */
    .total-balance {
      background: linear-gradient(135deg, #161b22 0%, #1c2128 100%);
      border: 1px solid #30363d;
      border-radius: 16px;
      padding: 30px;
      margin-bottom: 30px;
      text-align: center;
    }
    .total-balance .label { color: #7d8590; margin-bottom: 10px; }
    .total-balance .amount { font-size: 48px; font-weight: 700; color: #8b5cf6; }

    /* Wallets Grid */
    .wallets-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .wallet-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 20px;
    }
    .wallet-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 15px;
    }
    .wallet-name { font-weight: 600; font-size: 18px; }
    .wallet-address {
      color: #7d8590;
      font-size: 12px;
      font-family: monospace;
      cursor: pointer;
    }
    .wallet-address:hover { color: #8b5cf6; }
    .wallet-actions { display: flex; gap: 5px; }

    .balance-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #21262d;
    }
    .balance-row:last-child { border-bottom: none; }
    .balance-label { color: #7d8590; }
    .balance-value { font-weight: 600; }
    .balance-main {
      background: linear-gradient(90deg, rgba(139,92,246,0.1) 0%, transparent 100%);
      margin: 10px -20px;
      padding: 15px 20px;
    }
    .balance-main .balance-value { font-size: 24px; color: #8b5cf6; }

    .positive { color: #3fb950; }
    .negative { color: #f85149; }

    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 16px;
      padding: 30px;
      width: 100%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
    }
    .modal h2 { margin-bottom: 20px; color: #8b5cf6; }
    .modal-close {
      float: right;
      background: none;
      border: none;
      color: #7d8590;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
    }
    .modal-close:hover { color: #e6edf3; }

    .form-group { margin-bottom: 20px; }
    .form-group label { display: block; margin-bottom: 8px; color: #7d8590; }
    .form-group input, .form-group select {
      width: 100%;
      padding: 12px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #0d1117;
      color: #e6edf3;
      font-size: 14px;
    }
    .form-group input:focus { border-color: #8b5cf6; outline: none; }
    .form-group .hint { font-size: 12px; color: #7d8590; margin-top: 5px; }

    .form-row { display: flex; gap: 10px; }
    .form-row > * { flex: 1; }

    /* QR Code */
    .qr-container { text-align: center; margin: 20px 0; }
    .qr-container canvas { border-radius: 8px; }
    .copy-address {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px;
      margin-top: 15px;
    }
    .copy-address input {
      flex: 1;
      background: none;
      border: none;
      color: #e6edf3;
      font-family: monospace;
      font-size: 12px;
    }

    /* Status Messages */
    .status { padding: 12px; border-radius: 8px; margin-bottom: 15px; }
    .status-success { background: rgba(63,185,80,0.2); border: 1px solid #3fb950; }
    .status-error { background: rgba(248,81,73,0.2); border: 1px solid #f85149; }
    .status-info { background: rgba(139,92,246,0.2); border: 1px solid #8b5cf6; }

    /* Tabs */
    .tabs { display: flex; gap: 10px; margin-bottom: 20px; }
    .tab {
      padding: 10px 20px;
      background: #30363d;
      border: none;
      color: #7d8590;
    }
    .tab.active { background: #8b5cf6; color: white; }

    /* Swap Preview */
    .swap-preview {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .swap-preview .row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    .swap-preview .label { color: #7d8590; }

    /* Loading */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #30363d;
      border-top-color: #8b5cf6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 8px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Private Key Warning */
    .pk-warning {
      background: rgba(248,81,73,0.1);
      border: 1px solid #f85149;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }
    .pk-warning h4 { color: #f85149; margin-bottom: 5px; }
    .pk-warning p { color: #7d8590; font-size: 13px; }
  </style>
</head>
<body>
  <!-- Lock Screen -->
  <div id="lockScreen" class="lock-screen">
    <h1>Polygon Wallet Manager</h1>
    <p class="subtitle">Secure local wallet management</p>

    <div class="lock-box" id="unlockBox">
      <h2>Unlock Wallet</h2>
      <input type="password" id="unlockPassword" placeholder="Enter master password" onkeypress="if(event.key==='Enter')unlock()">
      <button onclick="unlock()">Unlock</button>
      <div class="error" id="unlockError"></div>
      <p class="info">Your wallets are encrypted locally. Password never leaves this device.</p>
    </div>

    <div class="lock-box" id="setupBox" style="display:none;">
      <h2>Create Master Password</h2>
      <input type="password" id="newPassword" placeholder="Create password (min 8 chars)">
      <input type="password" id="confirmPassword" placeholder="Confirm password" onkeypress="if(event.key==='Enter')createPassword()">
      <button onclick="createPassword()">Create Wallet Store</button>
      <div class="error" id="setupError"></div>
      <p class="info">This password encrypts all your private keys. Choose a strong password and don't forget it!</p>
    </div>
  </div>

  <!-- Main App -->
  <div id="app" class="app">
    <div class="header">
      <h1>Wallet Manager</h1>
      <div class="header-actions">
        <button onclick="showCreateWallet()">+ Create Wallet</button>
        <button class="btn-secondary" onclick="showImportWallet()">Import</button>
        <button class="btn-secondary" onclick="refreshAll()">Refresh</button>
        <button class="btn-secondary btn-small" onclick="showBackup()">Backup</button>
        <button class="btn-danger btn-small" onclick="lock()">Lock</button>
      </div>
    </div>

    <div class="total-balance">
      <div class="label">Total USDC.e Balance</div>
      <div class="amount" id="totalBalance">$0.00</div>
    </div>

    <div class="wallets-grid" id="walletsGrid">
      <!-- Wallet cards rendered here -->
    </div>
  </div>

  <!-- Create Wallet Modal -->
  <div class="modal-overlay" id="createModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('createModal')">&times;</button>
      <h2>Create New Wallet</h2>
      <div class="form-group">
        <label>Wallet Name</label>
        <input type="text" id="createName" placeholder="e.g., Trading Bot 1">
      </div>
      <div class="form-group">
        <label>Wallet Type</label>
        <select id="createType">
          <option value="proxy">Proxy (Trading Wallet)</option>
          <option value="funding">Funding (Main Wallet)</option>
        </select>
        <p class="hint">Funding wallets are used to fund proxy wallets</p>
      </div>
      <button onclick="createWallet()">Generate Wallet</button>

      <div id="newWalletInfo" style="display:none; margin-top:20px;">
        <div class="pk-warning">
          <h4>Save Your Private Key!</h4>
          <p>This is the only time you'll see it. Store it securely offline.</p>
        </div>
        <div class="form-group">
          <label>Address</label>
          <input type="text" id="newAddress" readonly>
        </div>
        <div class="form-group">
          <label>Private Key</label>
          <input type="text" id="newPrivateKey" readonly>
          <button class="btn-small btn-secondary" onclick="copyNewPK()" style="margin-top:10px;">Copy Private Key</button>
        </div>
        <button class="btn-success" onclick="confirmSaveWallet()">I've Saved It - Add Wallet</button>
      </div>
    </div>
  </div>

  <!-- Import Wallet Modal -->
  <div class="modal-overlay" id="importModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('importModal')">&times;</button>
      <h2>Import Wallet</h2>
      <div class="form-group">
        <label>Wallet Name</label>
        <input type="text" id="importName" placeholder="e.g., Main Wallet">
      </div>
      <div class="form-group">
        <label>Wallet Type</label>
        <select id="importType">
          <option value="proxy">Proxy (Trading Wallet)</option>
          <option value="funding">Funding (Main Wallet)</option>
        </select>
      </div>
      <div class="form-group">
        <label>Private Key</label>
        <input type="password" id="importPK" placeholder="0x...">
        <p class="hint">Your private key is encrypted and never leaves this device</p>
      </div>
      <button onclick="importWallet()">Import Wallet</button>
    </div>
  </div>

  <!-- Rename Wallet Modal -->
  <div class="modal-overlay" id="renameModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('renameModal')">&times;</button>
      <h2>Rename Wallet</h2>
      <input type="hidden" id="renameAddress">
      <div class="form-group">
        <label>New Name</label>
        <input type="text" id="renameName" placeholder="e.g., Bot Wallet 1">
      </div>
      <div class="form-group">
        <label>Wallet Type</label>
        <select id="renameType">
          <option value="proxy">Proxy (Trading Wallet)</option>
          <option value="funding">Funding (Main Wallet)</option>
        </select>
      </div>
      <button onclick="saveRename()">Save</button>
    </div>
  </div>

  <!-- Quick Fund Modal -->
  <div class="modal-overlay" id="quickFundModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('quickFundModal')">&times;</button>
      <h2>Quick Fund Proxy</h2>
      <div id="quickFundStatus"></div>
      <div class="form-group">
        <label>From (Funding Wallet)</label>
        <select id="quickFundFrom"></select>
      </div>
      <div class="form-group">
        <label>To (Proxy Wallet)</label>
        <input type="text" id="quickFundTo" readonly>
      </div>
      <div class="form-group">
        <label>Token</label>
        <select id="quickFundToken">
          <option value="USDC.E">USDC.e</option>
          <option value="USDC">USDC</option>
          <option value="POL">POL (for gas)</option>
        </select>
      </div>
      <div class="form-group">
        <label>Amount</label>
        <input type="number" id="quickFundAmount" placeholder="0.00" step="0.01">
        <div style="display:flex; gap:5px; margin-top:5px;">
          <button class="btn-small btn-secondary" onclick="setQuickFundAmount(10)">$10</button>
          <button class="btn-small btn-secondary" onclick="setQuickFundAmount(25)">$25</button>
          <button class="btn-small btn-secondary" onclick="setQuickFundAmount(50)">$50</button>
          <button class="btn-small btn-secondary" onclick="setQuickFundAmount(100)">$100</button>
        </div>
      </div>
      <button onclick="executeQuickFund()" id="quickFundBtn">Fund Wallet</button>
    </div>
  </div>

  <!-- Send Modal -->
  <div class="modal-overlay" id="sendModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('sendModal')">&times;</button>
      <h2>Send Crypto</h2>
      <div id="sendStatus"></div>
      <div class="form-group">
        <label>From Wallet</label>
        <select id="sendFrom"></select>
      </div>
      <div class="form-group">
        <label>Token</label>
        <select id="sendToken">
          <option value="USDC.E">USDC.e</option>
          <option value="USDC">USDC</option>
          <option value="POL">POL (MATIC)</option>
        </select>
      </div>
      <div class="form-group">
        <label>To Address</label>
        <input type="text" id="sendTo" placeholder="0x...">
      </div>
      <div class="form-group">
        <label>Amount</label>
        <input type="number" id="sendAmount" placeholder="0.00" step="0.000001">
        <button class="btn-small btn-secondary" onclick="sendMax()" style="margin-top:5px;">Max</button>
      </div>
      <button onclick="sendCrypto()" id="sendBtn">Send</button>
    </div>
  </div>

  <!-- Receive Modal -->
  <div class="modal-overlay" id="receiveModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('receiveModal')">&times;</button>
      <h2>Receive Crypto</h2>
      <div class="form-group">
        <label>Select Wallet</label>
        <select id="receiveWallet" onchange="updateReceiveQR()"></select>
      </div>
      <div class="qr-container">
        <canvas id="receiveQR"></canvas>
      </div>
      <div class="copy-address">
        <input type="text" id="receiveAddress" readonly>
        <button class="btn-small" onclick="copyReceiveAddress()">Copy</button>
      </div>
    </div>
  </div>

  <!-- Swap Modal -->
  <div class="modal-overlay" id="swapModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('swapModal')">&times;</button>
      <h2>Swap Tokens (1inch)</h2>
      <div id="swapStatus"></div>
      <div class="form-group">
        <label>From Wallet</label>
        <select id="swapWallet"></select>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label>From Token</label>
          <select id="swapFrom" onchange="getSwapQuote()">
            <option value="USDC">USDC</option>
            <option value="USDC.E">USDC.e</option>
            <option value="POL">POL</option>
          </select>
        </div>
        <div class="form-group">
          <label>To Token</label>
          <select id="swapTo" onchange="getSwapQuote()">
            <option value="USDC.E">USDC.e</option>
            <option value="USDC">USDC</option>
            <option value="POL">POL</option>
          </select>
        </div>
      </div>
      <div class="form-group">
        <label>Amount</label>
        <input type="number" id="swapAmount" placeholder="0.00" step="0.000001" oninput="getSwapQuote()">
      </div>
      <div class="swap-preview" id="swapPreview" style="display:none;">
        <div class="row"><span class="label">You Send</span><span id="swapSend">-</span></div>
        <div class="row"><span class="label">You Receive</span><span id="swapReceive">-</span></div>
        <div class="row"><span class="label">Rate</span><span id="swapRate">-</span></div>
      </div>
      <button onclick="executeSwap()" id="swapBtn" disabled>Get Quote First</button>
      <p class="hint" style="margin-top:10px;">Swaps use 1inch aggregator. Your private key never leaves this device.</p>
    </div>
  </div>

  <!-- Backup Modal -->
  <div class="modal-overlay" id="backupModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('backupModal')">&times;</button>
      <h2>Backup & Restore</h2>
      <p style="color:#7d8590;margin-bottom:20px;">Backup is encrypted with your master password. Same password required to restore.</p>

      <div style="display:flex;gap:15px;margin-bottom:30px;">
        <button onclick="exportBackup()" style="flex:1;">üì• Export Backup</button>
        <label style="flex:1;">
          <input type="file" id="importFile" accept=".json" onchange="importBackup(event)" style="display:none;">
          <button class="btn-secondary" onclick="document.getElementById('importFile').click()" style="width:100%;">üì§ Import Backup</button>
        </label>
      </div>

      <div id="backupStatus"></div>

      <div class="pk-warning">
        <h4>Backup Contents</h4>
        <p>‚Ä¢ All wallets (encrypted private keys)<br>‚Ä¢ Wallet names & types<br>‚Ä¢ P&L starting balances</p>
      </div>
    </div>
  </div>

  <!-- Export PK Modal -->
  <div class="modal-overlay" id="exportModal">
    <div class="modal">
      <button class="modal-close" onclick="closeModal('exportModal')">&times;</button>
      <h2>Export Private Key</h2>
      <div class="pk-warning">
        <h4>Security Warning</h4>
        <p>Never share your private key. Anyone with it has full control of your wallet.</p>
      </div>
      <div class="form-group">
        <label>Wallet</label>
        <input type="text" id="exportWalletName" readonly>
      </div>
      <div class="form-group">
        <label>Private Key</label>
        <input type="password" id="exportPK" readonly>
        <button class="btn-small btn-secondary" onclick="toggleExportPK()" style="margin-top:5px;">Show/Hide</button>
        <button class="btn-small" onclick="copyExportPK()" style="margin-top:5px; margin-left:5px;">Copy</button>
      </div>
    </div>
  </div>

  <script>
    // ============ CRYPTO UTILS ============
    const SALT_LENGTH = 16;
    const IV_LENGTH = 12;
    const ITERATIONS = 100000;

    async function deriveKey(password, salt) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: ITERATIONS, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    }

    async function encrypt(data, password) {
      const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
      const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
      const key = await deriveKey(password, salt);
      const enc = new TextEncoder();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        enc.encode(JSON.stringify(data))
      );
      // Combine salt + iv + encrypted data
      const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
      combined.set(salt, 0);
      combined.set(iv, salt.length);
      combined.set(new Uint8Array(encrypted), salt.length + iv.length);
      return btoa(String.fromCharCode(...combined));
    }

    async function decrypt(encryptedB64, password) {
      const combined = Uint8Array.from(atob(encryptedB64), c => c.charCodeAt(0));
      const salt = combined.slice(0, SALT_LENGTH);
      const iv = combined.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
      const data = combined.slice(SALT_LENGTH + IV_LENGTH);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, data);
      return JSON.parse(new TextDecoder().decode(decrypted));
    }

    // ============ STATE ============
    let masterPassword = null;
    let wallets = []; // { name, address, encryptedPK, type: 'funding'|'proxy' }
    let balances = {}; // address -> { 'USDC.E': x, 'USDC': y, 'POL': z }
    let startingBalances = {}; // address -> { 'USDC.E': x, timestamp: ms }
    let pendingNewWallet = null;
    let addressBook = []; // { name, address }

    // ============ RPC CONFIG ============
    const RPC_URL = 'https://polygon-bor-rpc.publicnode.com';
    const CHAIN_ID = 137;
    const TOKENS = {
      'USDC.E': { address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', decimals: 6 },
      'USDC': { address: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359', decimals: 6 },
      'POL': { address: 'native', decimals: 18 }
    };

    // 1inch config
    const ONEINCH_API = 'https://api.1inch.dev/swap/v6.0/137';
    const ONEINCH_ROUTER = '0x111111125421ca6dc452d289314280a0f8842a65';
    // User needs to set their own API key
    let ONEINCH_API_KEY = localStorage.getItem('oneinch_api_key') || '';

    // ============ STORAGE ============
    function saveWallets() {
      localStorage.setItem('wallet_manager_data', JSON.stringify(wallets));
    }

    function loadWallets() {
      const data = localStorage.getItem('wallet_manager_data');
      if (data) {
        wallets = JSON.parse(data);
      }
    }

    function saveStartingBalances() {
      localStorage.setItem('wallet_manager_pnl', JSON.stringify(startingBalances));
    }

    function loadStartingBalances() {
      const data = localStorage.getItem('wallet_manager_pnl');
      if (data) {
        startingBalances = JSON.parse(data);
      }
    }

    function hasExistingStore() {
      return localStorage.getItem('wallet_manager_data') !== null;
    }

    // ============ AUTH ============
    async function unlock() {
      const password = document.getElementById('unlockPassword').value;
      if (!password) return;

      try {
        // Try to decrypt first wallet to verify password
        loadWallets();
        loadStartingBalances();
        if (wallets.length > 0) {
          await decrypt(wallets[0].encryptedPK, password);
        }
        masterPassword = password;
        document.getElementById('lockScreen').style.display = 'none';
        document.getElementById('app').classList.add('active');
        await refreshAll();
      } catch (e) {
        document.getElementById('unlockError').textContent = 'Wrong password';
      }
    }

    async function createPassword() {
      const password = document.getElementById('newPassword').value;
      const confirm = document.getElementById('confirmPassword').value;

      if (password.length < 8) {
        document.getElementById('setupError').textContent = 'Password must be at least 8 characters';
        return;
      }
      if (password !== confirm) {
        document.getElementById('setupError').textContent = 'Passwords do not match';
        return;
      }

      masterPassword = password;
      wallets = [];
      saveWallets();

      document.getElementById('lockScreen').style.display = 'none';
      document.getElementById('app').classList.add('active');
    }

    function lock() {
      masterPassword = null;
      document.getElementById('app').classList.remove('active');
      document.getElementById('lockScreen').style.display = 'flex';
      document.getElementById('unlockPassword').value = '';
      document.getElementById('unlockError').textContent = '';
    }

    // ============ WALLET MANAGEMENT ============
    function showCreateWallet() {
      document.getElementById('createName').value = '';
      document.getElementById('newWalletInfo').style.display = 'none';
      pendingNewWallet = null;
      document.getElementById('createModal').classList.add('active');
    }

    async function createWallet() {
      const name = document.getElementById('createName').value.trim();
      const type = document.getElementById('createType').value;
      if (!name) {
        alert('Enter a wallet name');
        return;
      }

      // Generate new wallet using ethers.js
      const wallet = ethers.Wallet.createRandom();

      pendingNewWallet = {
        name,
        address: wallet.address,
        privateKey: wallet.privateKey,
        type
      };

      document.getElementById('newAddress').value = wallet.address;
      document.getElementById('newPrivateKey').value = wallet.privateKey;
      document.getElementById('newWalletInfo').style.display = 'block';
    }

    function copyNewPK() {
      navigator.clipboard.writeText(document.getElementById('newPrivateKey').value);
      alert('Private key copied!');
    }

    async function confirmSaveWallet() {
      if (!pendingNewWallet) return;

      const encryptedPK = await encrypt(pendingNewWallet.privateKey, masterPassword);
      wallets.push({
        name: pendingNewWallet.name,
        address: pendingNewWallet.address,
        encryptedPK,
        type: pendingNewWallet.type || 'proxy'
      });
      saveWallets();

      pendingNewWallet = null;
      closeModal('createModal');
      await refreshAll();
    }

    function showImportWallet() {
      document.getElementById('importName').value = '';
      document.getElementById('importPK').value = '';
      document.getElementById('importModal').classList.add('active');
    }

    async function importWallet() {
      const name = document.getElementById('importName').value.trim();
      const type = document.getElementById('importType').value;
      let pk = document.getElementById('importPK').value.trim();

      if (!name || !pk) {
        alert('Enter name and private key');
        return;
      }

      // Normalize PK
      if (!pk.startsWith('0x')) pk = '0x' + pk;

      try {
        const wallet = new ethers.Wallet(pk);
        const encryptedPK = await encrypt(pk, masterPassword);

        // Check if already exists
        if (wallets.find(w => w.address.toLowerCase() === wallet.address.toLowerCase())) {
          alert('Wallet already exists');
          return;
        }

        wallets.push({
          name,
          address: wallet.address,
          encryptedPK,
          type: type || 'proxy'
        });
        saveWallets();
        closeModal('importModal');
        await refreshAll();
      } catch (e) {
        alert('Invalid private key');
      }
    }

    async function deleteWallet(address) {
      if (!confirm('Delete this wallet? Make sure you have the private key backed up!')) return;
      wallets = wallets.filter(w => w.address.toLowerCase() !== address.toLowerCase());
      delete balances[address.toLowerCase()];
      saveWallets();
      renderWallets();
      updateTotalBalance();
    }

    // ============ BALANCE CHECKING ============
    async function rpcCall(method, params) {
      const res = await fetch(RPC_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
      });
      const data = await res.json();
      if (data.error) throw new Error(data.error.message);
      return data.result;
    }

    async function getBalance(address, token) {
      if (token === 'POL') {
        const result = await rpcCall('eth_getBalance', [address, 'latest']);
        return hexToNumber(result, 18);
      } else {
        const tokenAddr = TOKENS[token].address;
        const paddedAddr = address.toLowerCase().replace('0x', '').padStart(64, '0');
        const data = '0x70a08231' + paddedAddr;
        const result = await rpcCall('eth_call', [{ to: tokenAddr, data }, 'latest']);
        return hexToNumber(result, TOKENS[token].decimals);
      }
    }

    function hexToNumber(hex, decimals) {
      if (!hex || hex === '0x') return 0;
      const bigInt = BigInt(hex);
      const divisor = BigInt(10 ** decimals);
      const whole = bigInt / divisor;
      const frac = bigInt % divisor;
      return Number(whole) + Number(frac) / (10 ** decimals);
    }

    async function refreshAll() {
      for (const wallet of wallets) {
        const addr = wallet.address.toLowerCase();
        balances[addr] = {};
        try {
          balances[addr]['USDC.E'] = await getBalance(wallet.address, 'USDC.E');
          balances[addr]['USDC'] = await getBalance(wallet.address, 'USDC');
          balances[addr]['POL'] = await getBalance(wallet.address, 'POL');
        } catch (e) {
          console.error('Error fetching balance for', wallet.address, e);
        }
      }
      renderWallets();
      updateTotalBalance();
      updateSelects();
    }

    // ============ RENDERING ============
    function renderWallets() {
      const grid = document.getElementById('walletsGrid');
      if (wallets.length === 0) {
        grid.innerHTML = '<div style="text-align:center;color:#7d8590;padding:40px;">No wallets yet. Create or import one to get started.</div>';
        return;
      }

      // Group by type
      const funding = wallets.filter(w => w.type === 'funding');
      const proxy = wallets.filter(w => w.type !== 'funding');

      let html = '';

      // Funding wallets section
      if (funding.length > 0) {
        html += '<div class="wallet-section"><h2>üí∞ Funding Wallets</h2><div class="wallets-grid">';
        html += funding.map(w => renderWalletCard(w)).join('');
        html += '</div></div>';
      }

      // Proxy wallets section
      if (proxy.length > 0) {
        html += '<div class="wallet-section"><h2>ü§ñ Proxy/Trading Wallets</h2>';
        if (funding.length > 0) {
          html += '<div style="margin-bottom:15px;"><button class="btn-small btn-warning" onclick="showBulkFund()">Fund All Proxies</button></div>';
        }
        html += '<div class="wallets-grid">';
        html += proxy.map(w => renderWalletCard(w)).join('');
        html += '</div></div>';
      }

      grid.innerHTML = html;
    }

    function renderWalletCard(w) {
      const addr = w.address.toLowerCase();
      const bal = balances[addr] || {};
      const typeClass = w.type === 'funding' ? 'funding' : 'proxy';
      const typeLabel = w.type === 'funding' ? 'FUNDING' : 'PROXY';
      const hasFunding = wallets.some(x => x.type === 'funding');
      const pnl = getPnL(w.address);
      const hasPnL = pnl !== null;

      return `
        <div class="wallet-card">
          <div class="wallet-header">
            <div>
              <div class="wallet-name">
                ${w.name}
                <span class="wallet-type ${typeClass}">${typeLabel}</span>
              </div>
              <div class="wallet-address" onclick="copyAddress('${w.address}')" title="Click to copy">${w.address.slice(0,8)}...${w.address.slice(-6)}</div>
            </div>
            <div class="wallet-actions">
              <button class="btn-small btn-secondary" onclick="showRename('${w.address}')" title="Edit">‚úèÔ∏è</button>
              <button class="btn-small btn-secondary" onclick="showExportPK('${w.address}')">Export</button>
              <button class="btn-small btn-danger" onclick="deleteWallet('${w.address}')">X</button>
            </div>
          </div>
          <div class="balance-row balance-main">
            <span class="balance-label">USDC.e ${hasPnL ? formatPnL(pnl) : ''}</span>
            <span class="balance-value">${formatUsd(bal['USDC.E'] || 0)}</span>
          </div>
          <div class="balance-row">
            <span class="balance-label">USDC</span>
            <span class="balance-value">${formatUsd(bal['USDC'] || 0)}</span>
          </div>
          <div class="balance-row">
            <span class="balance-label">POL ${(bal['POL'] || 0) < 0.1 ? '<span style="color:#f85149;font-size:10px;">‚ö†Ô∏è LOW GAS</span>' : ''}</span>
            <span class="balance-value" style="${(bal['POL'] || 0) < 0.1 ? 'color:#f85149' : ''}">${(bal['POL'] || 0).toFixed(4)}</span>
          </div>
          <div style="display:flex;gap:10px;margin-top:15px;flex-wrap:wrap;">
            <button class="btn-small btn-success" onclick="showSend('${w.address}')">Send</button>
            <button class="btn-small" onclick="showReceive('${w.address}')">Receive</button>
            <button class="btn-small btn-secondary" onclick="showSwap('${w.address}')">Swap</button>
            ${w.type !== 'funding' && hasFunding ? `<button class="btn-small btn-warning" onclick="showQuickFund('${w.address}')">Fund</button>` : ''}
            ${w.type === 'funding' ? `<button class="btn-small btn-secondary" onclick="showCollectAll('${w.address}')">Collect</button>` : ''}
            <button class="btn-small btn-secondary" onclick="resetPnL('${w.address}')" title="Reset P&L">‚Ü∫</button>
          </div>
        </div>
      `;
    }

    function updateTotalBalance() {
      let total = 0;
      let fundingTotal = 0;
      let proxyTotal = 0;
      let totalPnL = 0;
      let hasPnL = false;

      for (const w of wallets) {
        const addr = w.address.toLowerCase();
        const bal = balances[addr]?.['USDC.E'] || 0;
        total += bal;
        if (w.type === 'funding') {
          fundingTotal += bal;
        } else {
          proxyTotal += bal;
        }

        const pnl = getPnL(w.address);
        if (pnl !== null) {
          totalPnL += pnl;
          hasPnL = true;
        }
      }

      let html = formatUsd(total);
      if (hasPnL) {
        html += ` ${formatPnL(totalPnL)}`;
      }
      if (wallets.some(w => w.type === 'funding')) {
        html += `<div style="font-size:14px;color:#7d8590;margin-top:10px;">Funding: ${formatUsd(fundingTotal)} | Proxies: ${formatUsd(proxyTotal)}</div>`;
      }
      if (wallets.length > 0) {
        html += `<div style="margin-top:10px;"><button class="btn-small btn-secondary" onclick="resetAllPnL()">Reset All P&L</button></div>`;
      }

      document.getElementById('totalBalance').innerHTML = html;
    }

    function updateSelects() {
      const options = wallets.map(w =>
        `<option value="${w.address}">${w.name} (${w.address.slice(0,6)}...)</option>`
      ).join('');

      ['sendFrom', 'receiveWallet', 'swapWallet'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = options;
      });

      // Update quickFundFrom with funding wallets only
      const fundingOptions = wallets.filter(w => w.type === 'funding').map(w => {
        const bal = balances[w.address.toLowerCase()]?.['USDC.E'] || 0;
        return `<option value="${w.address}">${w.name} ($${bal.toFixed(2)})</option>`;
      }).join('');
      const qff = document.getElementById('quickFundFrom');
      if (qff) qff.innerHTML = fundingOptions;
    }

    // ============ SEND ============
    function showSend(fromAddress) {
      updateSelects();
      document.getElementById('sendFrom').value = fromAddress;
      document.getElementById('sendTo').value = '';
      document.getElementById('sendAmount').value = '';
      document.getElementById('sendStatus').innerHTML = '';
      document.getElementById('sendModal').classList.add('active');
    }

    function sendMax() {
      const fromAddr = document.getElementById('sendFrom').value.toLowerCase();
      const token = document.getElementById('sendToken').value;
      const bal = balances[fromAddr]?.[token] || 0;
      // Leave some for gas if sending POL
      const amount = token === 'POL' ? Math.max(0, bal - 0.1) : bal;
      document.getElementById('sendAmount').value = amount.toFixed(6);
    }

    async function sendCrypto() {
      const fromAddr = document.getElementById('sendFrom').value;
      const toAddr = document.getElementById('sendTo').value.trim();
      const token = document.getElementById('sendToken').value;
      const amount = parseFloat(document.getElementById('sendAmount').value);

      if (!toAddr || !amount || amount <= 0) {
        alert('Enter valid address and amount');
        return;
      }

      if (!toAddr.match(/^0x[a-fA-F0-9]{40}$/)) {
        alert('Invalid address format');
        return;
      }

      const btn = document.getElementById('sendBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner"></span>Sending...';
      document.getElementById('sendStatus').innerHTML = '';

      try {
        // Get private key
        const wallet = wallets.find(w => w.address.toLowerCase() === fromAddr.toLowerCase());
        const pk = await decrypt(wallet.encryptedPK, masterPassword);

        const provider = new ethers.JsonRpcProvider(RPC_URL);
        const signer = new ethers.Wallet(pk, provider);

        let tx;
        if (token === 'POL') {
          // Native transfer
          tx = await signer.sendTransaction({
            to: toAddr,
            value: ethers.parseEther(amount.toString())
          });
        } else {
          // ERC20 transfer
          const tokenContract = new ethers.Contract(
            TOKENS[token].address,
            ['function transfer(address to, uint256 amount) returns (bool)'],
            signer
          );
          const decimals = TOKENS[token].decimals;
          const amountWei = ethers.parseUnits(amount.toFixed(decimals), decimals);
          tx = await tokenContract.transfer(toAddr, amountWei);
        }

        document.getElementById('sendStatus').innerHTML = `
          <div class="status status-info">
            Transaction sent! Waiting for confirmation...<br>
            <a href="https://polygonscan.com/tx/${tx.hash}" target="_blank" style="color:#8b5cf6;">${tx.hash.slice(0,20)}...</a>
          </div>
        `;

        await tx.wait();

        document.getElementById('sendStatus').innerHTML = `
          <div class="status status-success">
            Success! <a href="https://polygonscan.com/tx/${tx.hash}" target="_blank" style="color:#3fb950;">View on PolygonScan</a>
          </div>
        `;

        await refreshAll();
      } catch (e) {
        console.error(e);
        document.getElementById('sendStatus').innerHTML = `
          <div class="status status-error">Error: ${e.message}</div>
        `;
      }

      btn.disabled = false;
      btn.textContent = 'Send';
    }

    // ============ RECEIVE ============
    function showReceive(address) {
      updateSelects();
      document.getElementById('receiveWallet').value = address;
      document.getElementById('receiveModal').classList.add('active');
      updateReceiveQR();
    }

    function updateReceiveQR() {
      const address = document.getElementById('receiveWallet').value;
      document.getElementById('receiveAddress').value = address;

      QRCode.toCanvas(document.getElementById('receiveQR'), address, {
        width: 200,
        color: { dark: '#8b5cf6', light: '#161b22' }
      });
    }

    function copyReceiveAddress() {
      navigator.clipboard.writeText(document.getElementById('receiveAddress').value);
      alert('Address copied!');
    }

    // ============ SWAP ============
    let swapQuote = null;

    function showSwap(address) {
      if (!ONEINCH_API_KEY) {
        ONEINCH_API_KEY = prompt('Enter your 1inch API key (get free at portal.1inch.dev):');
        if (ONEINCH_API_KEY) {
          localStorage.setItem('oneinch_api_key', ONEINCH_API_KEY);
        } else {
          return;
        }
      }

      updateSelects();
      document.getElementById('swapWallet').value = address;
      document.getElementById('swapAmount').value = '';
      document.getElementById('swapPreview').style.display = 'none';
      document.getElementById('swapStatus').innerHTML = '';
      document.getElementById('swapBtn').disabled = true;
      document.getElementById('swapBtn').textContent = 'Get Quote First';
      swapQuote = null;
      document.getElementById('swapModal').classList.add('active');
    }

    async function getSwapQuote() {
      const fromToken = document.getElementById('swapFrom').value;
      const toToken = document.getElementById('swapTo').value;
      const amount = parseFloat(document.getElementById('swapAmount').value);

      if (!amount || amount <= 0 || fromToken === toToken) {
        document.getElementById('swapPreview').style.display = 'none';
        document.getElementById('swapBtn').disabled = true;
        return;
      }

      try {
        const decimals = TOKENS[fromToken].decimals;
        const amountWei = BigInt(Math.floor(amount * (10 ** decimals))).toString();

        const fromAddr = fromToken === 'POL' ? '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' : TOKENS[fromToken].address;
        const toAddr = toToken === 'POL' ? '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' : TOKENS[toToken].address;

        const url = `${ONEINCH_API}/quote?src=${fromAddr}&dst=${toAddr}&amount=${amountWei}`;
        const res = await fetch(url, {
          headers: { 'Authorization': `Bearer ${ONEINCH_API_KEY}` }
        });

        if (!res.ok) {
          throw new Error(await res.text());
        }

        const quote = await res.json();
        swapQuote = quote;

        const toDecimals = TOKENS[toToken].decimals;
        const receiveAmount = Number(BigInt(quote.dstAmount)) / (10 ** toDecimals);
        const rate = receiveAmount / amount;

        document.getElementById('swapSend').textContent = `${amount.toFixed(4)} ${fromToken}`;
        document.getElementById('swapReceive').textContent = `${receiveAmount.toFixed(4)} ${toToken}`;
        document.getElementById('swapRate').textContent = `1 ${fromToken} = ${rate.toFixed(6)} ${toToken}`;
        document.getElementById('swapPreview').style.display = 'block';
        document.getElementById('swapBtn').disabled = false;
        document.getElementById('swapBtn').textContent = 'Execute Swap';
      } catch (e) {
        console.error('Quote error:', e);
        document.getElementById('swapPreview').style.display = 'none';
        document.getElementById('swapBtn').disabled = true;
      }
    }

    async function executeSwap() {
      const walletAddr = document.getElementById('swapWallet').value;
      const fromToken = document.getElementById('swapFrom').value;
      const toToken = document.getElementById('swapTo').value;
      const amount = parseFloat(document.getElementById('swapAmount').value);

      if (!swapQuote || !amount) return;

      const btn = document.getElementById('swapBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner"></span>Swapping...';
      document.getElementById('swapStatus').innerHTML = '';

      try {
        const wallet = wallets.find(w => w.address.toLowerCase() === walletAddr.toLowerCase());
        const pk = await decrypt(wallet.encryptedPK, masterPassword);

        const provider = new ethers.JsonRpcProvider(RPC_URL);
        const signer = new ethers.Wallet(pk, provider);

        const decimals = TOKENS[fromToken].decimals;
        const amountWei = BigInt(Math.floor(amount * (10 ** decimals))).toString();

        // Check and approve if ERC20
        if (fromToken !== 'POL') {
          const tokenContract = new ethers.Contract(
            TOKENS[fromToken].address,
            [
              'function allowance(address owner, address spender) view returns (uint256)',
              'function approve(address spender, uint256 amount) returns (bool)'
            ],
            signer
          );

          const allowance = await tokenContract.allowance(walletAddr, ONEINCH_ROUTER);
          if (allowance < BigInt(amountWei)) {
            document.getElementById('swapStatus').innerHTML = '<div class="status status-info">Approving token...</div>';
            const approveTx = await tokenContract.approve(ONEINCH_ROUTER, ethers.MaxUint256);
            await approveTx.wait();
          }
        }

        // Get swap data
        const fromAddr = fromToken === 'POL' ? '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' : TOKENS[fromToken].address;
        const toAddr = toToken === 'POL' ? '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' : TOKENS[toToken].address;

        const swapUrl = `${ONEINCH_API}/swap?src=${fromAddr}&dst=${toAddr}&amount=${amountWei}&from=${walletAddr}&slippage=1&disableEstimate=false`;
        const swapRes = await fetch(swapUrl, {
          headers: { 'Authorization': `Bearer ${ONEINCH_API_KEY}` }
        });

        if (!swapRes.ok) {
          throw new Error(await swapRes.text());
        }

        const swapData = await swapRes.json();

        document.getElementById('swapStatus').innerHTML = '<div class="status status-info">Executing swap...</div>';

        const tx = await signer.sendTransaction({
          to: swapData.tx.to,
          data: swapData.tx.data,
          value: swapData.tx.value,
          gasLimit: swapData.tx.gas
        });

        document.getElementById('swapStatus').innerHTML = `
          <div class="status status-info">
            Transaction sent! <a href="https://polygonscan.com/tx/${tx.hash}" target="_blank" style="color:#8b5cf6;">View</a>
          </div>
        `;

        await tx.wait();

        document.getElementById('swapStatus').innerHTML = `
          <div class="status status-success">
            Swap complete! <a href="https://polygonscan.com/tx/${tx.hash}" target="_blank" style="color:#3fb950;">View on PolygonScan</a>
          </div>
        `;

        await refreshAll();
      } catch (e) {
        console.error(e);
        document.getElementById('swapStatus').innerHTML = `
          <div class="status status-error">Error: ${e.message}</div>
        `;
      }

      btn.disabled = false;
      btn.textContent = 'Execute Swap';
    }

    // ============ EXPORT PK ============
    async function showExportPK(address) {
      const wallet = wallets.find(w => w.address.toLowerCase() === address.toLowerCase());
      if (!wallet) return;

      try {
        const pk = await decrypt(wallet.encryptedPK, masterPassword);
        document.getElementById('exportWalletName').value = wallet.name;
        document.getElementById('exportPK').value = pk;
        document.getElementById('exportPK').type = 'password';
        document.getElementById('exportModal').classList.add('active');
      } catch (e) {
        alert('Error decrypting private key');
      }
    }

    function toggleExportPK() {
      const input = document.getElementById('exportPK');
      input.type = input.type === 'password' ? 'text' : 'password';
    }

    function copyExportPK() {
      navigator.clipboard.writeText(document.getElementById('exportPK').value);
      alert('Private key copied!');
    }

    // ============ RENAME WALLET ============
    function showRename(address) {
      const wallet = wallets.find(w => w.address.toLowerCase() === address.toLowerCase());
      if (!wallet) return;

      document.getElementById('renameAddress').value = address;
      document.getElementById('renameName').value = wallet.name;
      document.getElementById('renameType').value = wallet.type || 'proxy';
      document.getElementById('renameModal').classList.add('active');
    }

    function saveRename() {
      const address = document.getElementById('renameAddress').value;
      const newName = document.getElementById('renameName').value.trim();
      const newType = document.getElementById('renameType').value;

      if (!newName) {
        alert('Enter a wallet name');
        return;
      }

      const wallet = wallets.find(w => w.address.toLowerCase() === address.toLowerCase());
      if (wallet) {
        wallet.name = newName;
        wallet.type = newType;
        saveWallets();
        renderWallets();
      }
      closeModal('renameModal');
    }

    // ============ QUICK FUND ============
    function showQuickFund(toAddress) {
      const fundingWallets = wallets.filter(w => w.type === 'funding');
      if (fundingWallets.length === 0) {
        alert('No funding wallets. Create one first.');
        return;
      }

      const toWallet = wallets.find(w => w.address.toLowerCase() === toAddress.toLowerCase());
      document.getElementById('quickFundTo').value = `${toWallet.name} (${toAddress.slice(0,6)}...)`;
      document.getElementById('quickFundTo').dataset.address = toAddress;

      document.getElementById('quickFundFrom').innerHTML = fundingWallets.map(w => {
        const bal = balances[w.address.toLowerCase()]?.['USDC.E'] || 0;
        return `<option value="${w.address}">${w.name} ($${bal.toFixed(2)})</option>`;
      }).join('');

      document.getElementById('quickFundAmount').value = '';
      document.getElementById('quickFundStatus').innerHTML = '';
      document.getElementById('quickFundModal').classList.add('active');
    }

    function setQuickFundAmount(amount) {
      document.getElementById('quickFundAmount').value = amount;
    }

    async function executeQuickFund() {
      const fromAddr = document.getElementById('quickFundFrom').value;
      const toAddr = document.getElementById('quickFundTo').dataset.address;
      const token = document.getElementById('quickFundToken').value;
      const amount = parseFloat(document.getElementById('quickFundAmount').value);

      if (!amount || amount <= 0) {
        alert('Enter valid amount');
        return;
      }

      const btn = document.getElementById('quickFundBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner"></span>Funding...';
      document.getElementById('quickFundStatus').innerHTML = '';

      try {
        const wallet = wallets.find(w => w.address.toLowerCase() === fromAddr.toLowerCase());
        const pk = await decrypt(wallet.encryptedPK, masterPassword);

        const provider = new ethers.JsonRpcProvider(RPC_URL);
        const signer = new ethers.Wallet(pk, provider);

        let tx;
        if (token === 'POL') {
          tx = await signer.sendTransaction({
            to: toAddr,
            value: ethers.parseEther(amount.toString())
          });
        } else {
          const tokenContract = new ethers.Contract(
            TOKENS[token].address,
            ['function transfer(address to, uint256 amount) returns (bool)'],
            signer
          );
          const decimals = TOKENS[token].decimals;
          const amountWei = ethers.parseUnits(amount.toFixed(decimals), decimals);
          tx = await tokenContract.transfer(toAddr, amountWei);
        }

        document.getElementById('quickFundStatus').innerHTML = `<div class="status status-info">Sending... <a href="https://polygonscan.com/tx/${tx.hash}" target="_blank">${tx.hash.slice(0,12)}...</a></div>`;
        await tx.wait();

        document.getElementById('quickFundStatus').innerHTML = `<div class="status status-success">Funded! <a href="https://polygonscan.com/tx/${tx.hash}" target="_blank">View</a></div>`;
        await refreshAll();
      } catch (e) {
        document.getElementById('quickFundStatus').innerHTML = `<div class="status status-error">${e.message}</div>`;
      }

      btn.disabled = false;
      btn.textContent = 'Fund Wallet';
    }

    // ============ BULK FUND ALL PROXIES ============
    async function showBulkFund() {
      const funding = wallets.filter(w => w.type === 'funding');
      const proxy = wallets.filter(w => w.type !== 'funding');

      if (funding.length === 0) {
        alert('No funding wallet');
        return;
      }

      const amount = prompt(`Fund all ${proxy.length} proxy wallets?\nEnter USDC.e amount per wallet (or POL:0.1 for gas):`);
      if (!amount) return;

      let token = 'USDC.E';
      let sendAmount = parseFloat(amount);

      if (amount.toUpperCase().startsWith('POL:')) {
        token = 'POL';
        sendAmount = parseFloat(amount.split(':')[1]);
      }

      if (!sendAmount || sendAmount <= 0) {
        alert('Invalid amount');
        return;
      }

      const fromWallet = funding[0];
      const pk = await decrypt(fromWallet.encryptedPK, masterPassword);
      const provider = new ethers.JsonRpcProvider(RPC_URL);
      const signer = new ethers.Wallet(pk, provider);

      let success = 0;
      for (const w of proxy) {
        try {
          let tx;
          if (token === 'POL') {
            tx = await signer.sendTransaction({
              to: w.address,
              value: ethers.parseEther(sendAmount.toString())
            });
          } else {
            const tokenContract = new ethers.Contract(
              TOKENS[token].address,
              ['function transfer(address to, uint256 amount) returns (bool)'],
              signer
            );
            const amountWei = ethers.parseUnits(sendAmount.toFixed(6), 6);
            tx = await tokenContract.transfer(w.address, amountWei);
          }
          await tx.wait();
          success++;
          console.log(`Funded ${w.name}`);
        } catch (e) {
          console.error(`Failed ${w.name}:`, e.message);
        }
      }

      alert(`Funded ${success}/${proxy.length} wallets`);
      await refreshAll();
    }

    // ============ COLLECT ALL TO FUNDING ============
    async function showCollectAll(fundingAddress) {
      const proxy = wallets.filter(w => w.type !== 'funding');

      const token = prompt(`Collect from ${proxy.length} proxy wallets to this funding wallet?\nEnter token (USDC.E or USDC):`);
      if (!token || !['USDC.E', 'USDC'].includes(token.toUpperCase())) {
        if (token) alert('Invalid token. Use USDC.E or USDC');
        return;
      }

      let success = 0;
      let totalCollected = 0;

      for (const w of proxy) {
        try {
          const bal = balances[w.address.toLowerCase()]?.[token.toUpperCase()] || 0;
          if (bal < 0.01) continue; // Skip dust

          const pk = await decrypt(w.encryptedPK, masterPassword);
          const provider = new ethers.JsonRpcProvider(RPC_URL);
          const signer = new ethers.Wallet(pk, provider);

          const tokenContract = new ethers.Contract(
            TOKENS[token.toUpperCase()].address,
            ['function transfer(address to, uint256 amount) returns (bool)'],
            signer
          );

          const amountWei = ethers.parseUnits(bal.toFixed(6), 6);
          const tx = await tokenContract.transfer(fundingAddress, amountWei);
          await tx.wait();

          success++;
          totalCollected += bal;
          console.log(`Collected $${bal.toFixed(2)} from ${w.name}`);
        } catch (e) {
          console.error(`Failed ${w.name}:`, e.message);
        }
      }

      alert(`Collected $${totalCollected.toFixed(2)} from ${success} wallets`);
      await refreshAll();
    }

    // ============ BACKUP/RESTORE ============
    function showBackup() {
      document.getElementById('backupStatus').innerHTML = '';
      document.getElementById('backupModal').classList.add('active');
    }

    function exportBackup() {
      const backup = {
        version: 1,
        timestamp: Date.now(),
        wallets: wallets,
        startingBalances: startingBalances
      };

      const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `wallet-backup-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);

      document.getElementById('backupStatus').innerHTML = '<div class="status status-success">Backup downloaded!</div>';
    }

    async function importBackup(event) {
      const file = event.target.files[0];
      if (!file) return;

      try {
        const text = await file.text();
        const backup = JSON.parse(text);

        if (!backup.wallets || !Array.isArray(backup.wallets)) {
          throw new Error('Invalid backup file');
        }

        // Verify we can decrypt at least one wallet with current password
        if (backup.wallets.length > 0) {
          try {
            await decrypt(backup.wallets[0].encryptedPK, masterPassword);
          } catch {
            throw new Error('Wrong password - backup was created with different master password');
          }
        }

        // Merge or replace
        const action = confirm(`Found ${backup.wallets.length} wallets in backup.\n\nOK = Replace all\nCancel = Merge (add new only)`);

        if (action) {
          // Replace all
          wallets = backup.wallets;
          startingBalances = backup.startingBalances || {};
        } else {
          // Merge - add wallets that don't exist
          for (const w of backup.wallets) {
            if (!wallets.find(x => x.address.toLowerCase() === w.address.toLowerCase())) {
              wallets.push(w);
            }
          }
          startingBalances = { ...startingBalances, ...(backup.startingBalances || {}) };
        }

        saveWallets();
        saveStartingBalances();
        await refreshAll();

        document.getElementById('backupStatus').innerHTML = '<div class="status status-success">Backup restored!</div>';
      } catch (e) {
        document.getElementById('backupStatus').innerHTML = `<div class="status status-error">${e.message}</div>`;
      }

      event.target.value = '';
    }

    // ============ P&L TRACKING ============
    function resetPnL(address) {
      const addr = address.toLowerCase();
      const bal = balances[addr]?.['USDC.E'] || 0;
      startingBalances[addr] = { 'USDC.E': bal, timestamp: Date.now() };
      saveStartingBalances();
      renderWallets();
      updateTotalBalance();
    }

    function resetAllPnL() {
      if (!confirm('Reset P&L for all wallets?')) return;
      for (const w of wallets) {
        const addr = w.address.toLowerCase();
        const bal = balances[addr]?.['USDC.E'] || 0;
        startingBalances[addr] = { 'USDC.E': bal, timestamp: Date.now() };
      }
      saveStartingBalances();
      renderWallets();
      updateTotalBalance();
    }

    function getPnL(address) {
      const addr = address.toLowerCase();
      const current = balances[addr]?.['USDC.E'] || 0;
      const starting = startingBalances[addr]?.['USDC.E'];
      if (starting === undefined) return null;
      return current - starting;
    }

    // ============ UTILS ============
    function formatUsd(val) {
      return '$' + val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    function formatPnL(val) {
      if (val === null) return '';
      const sign = val >= 0 ? '+' : '';
      const color = val >= 0 ? '#3fb950' : '#f85149';
      return `<span style="color:${color}">${sign}${formatUsd(val)}</span>`;
    }

    function copyAddress(address) {
      navigator.clipboard.writeText(address);
      alert('Address copied!');
    }

    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
    }

    // Close modal on overlay click
    document.querySelectorAll('.modal-overlay').forEach(overlay => {
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) overlay.classList.remove('active');
      });
    });

    // ============ INIT ============
    if (hasExistingStore()) {
      document.getElementById('unlockBox').style.display = 'block';
      document.getElementById('setupBox').style.display = 'none';
    } else {
      document.getElementById('unlockBox').style.display = 'none';
      document.getElementById('setupBox').style.display = 'block';
    }
  </script>
</body>
</html>
